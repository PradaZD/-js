<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
      思考：变量提升机制好还是不好？
      在下面定义变量或是函数，在上面调用也不会报错，比较方便，但是不严谨。


       */

      /*
       在ES6中，基于let或者const等方式创建变量或者函数不存在变量提升机制。

       切断了全局变量和window属性的映射机制；

       注意：以后用let/const声明变量，一定要先声明再应用，这样更严谨。

        */
      // let a = 12;
      // let fn = function() {};
      // let fn = () => {};
      //ES6中创建一个函数相当于创建一个变量，赋值为一个函数

      // console.log(a);
      // let a = 12;
      // console.log(window.a); //undefined
      // console.log(a);

      /*
        在相同的作用域中，基于let不能声明相同名字的变量（不管用什么方式，在当前
        作用域下声明了变量，再次使用let创建都会报错）
        不带let/const，就跟ES6没有关系。
        虽然没有变量提升机制，但是在当前作用域代码自上而下执行之前，浏览器会做一个
        重复性检测，自上而下查找当前作用域下所有变量，一旦发现有重复的直接抛出异常，
        代码也就不会再执了。（也就是一旦有重复，一行代码也不执行）
        （虽然没有把变量提前声明定义，但是浏览器已经记住了，当前作用域下有哪些变量。）


         */
      b = 12;
      console.log(b);
      a = 12;
      console.log(a);
      let a = 13;
      console.log(a);
      //在var的时候，如果命名重复，不会重复声明 但是会重复赋值，也就是后面的值会覆盖前面。
      //在相同作用域中，基于let不能声明相同名字的变量；
      //在代码执行之前就已经报错了，在作用域形成之后 代码执行之前就已经有一个重复
      //检测机制，如果有重复就会直接报错。

      // let a = 10,
      //   b = 10;
      // let fn = function() {
      //   console.log(a, b); //报错
      //   //没有变量提升，私有作用域中一开始console a找不到a，所以报错；
      //   let a = (b = 20);
      //   console.log(a, b);
      // };
      // fn();
      // console.log(a, b);
    </script>
  </body>
</html>
